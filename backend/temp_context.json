{"content": "================================================\nFile: Cargo.toml\n================================================\n[package]\nname = \"briskit_editor\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ncrossterm = \"0.27.0\"\n\n\n================================================\nFile: src/editor.rs\n================================================\nuse crossterm::event::{read, Event, Event::Key, KeyCode::Char, KeyEvent, KeyModifiers};\nmod terminal;\nuse std::io::Error;\nuse terminal::{Position, Size, Terminal};\n\nconst NAME: &str = env!(\"CARGO_PKG_NAME\");\nconst VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n\npub struct Editor {\n    should_quit: bool,\n}\n\nimpl Editor {\n    pub const fn new() -> Self {\n        Self { should_quit: false }\n    }\n\n    pub fn run(&mut self) {\n        Terminal::initialise().unwrap();\n        let runner = self.repl();\n        Terminal::terminate().unwrap();\n        runner.unwrap();\n    }\n\n    fn repl(&mut self) -> Result<(), Error> {\n        loop {\n            self.refresh_screen()?;\n            if self.should_quit {\n                break;\n            }\n            let event = read()?;\n            self.evaluate_event(&event);\n        }\n        Ok(())\n    }\n\n    fn evaluate_event(&mut self, event: &Event) {\n        if let Key(KeyEvent {\n            code, modifiers, ..\n        }) = event\n        {\n            match code {\n                Char('c') if *modifiers == KeyModifiers::CONTROL => {\n                    self.should_quit = true;\n                }\n                _ => (),\n            }\n        }\n    }\n\n    fn draw_tilde() -> Result<(), Error> {\n        let Size { height, .. } = Terminal::size()?;\n        for _row in 0..height {\n            Terminal::clear_line()?;\n            if _row == height / 3 {\n                Self::draw_welcome_message()?;\n            } else {\n                Self::draw_empty_row()?;\n            }\n            if _row < height - 1 {\n                Terminal::print(\"\\r\\n\")?;\n            }\n        }\n        Ok(())\n    }\n\n    fn refresh_screen(&self) -> Result<(), Error> {\n        Terminal::hide_cursor()?;\n        if self.should_quit {\n            Terminal::clear_screen()?;\n            Terminal::print(\"Quitting already?\\r\\n\")?;\n        } else {\n            Self::draw_tilde()?;\n            Terminal::move_cursor_to(Position { x: 0, y: 0 })?;\n            Terminal::show_cursor()?;\n            Terminal::execute()?;\n        }\n        Ok(())\n    }\n\n    fn draw_empty_row() -> Result<(), Error> {\n        Terminal::print(\"~\")?;\n        Ok(())\n    }\n\n    fn draw_welcome_message() -> Result<(), Error> {\n        let mut welcome_message = format!(\"{NAME} editor -- version {VERSION}\");\n        let width = Terminal::size()?.width as usize;\n        let len = welcome_message.len();\n        let padding = (width - len) / 2;\n        let spaces = \" \".repeat(padding - 1);\n        welcome_message = format!(\"~{spaces}{welcome_message}\");\n        welcome_message.truncate(width - 1);\n        Terminal::print(welcome_message)?;\n        Ok(())\n    }\n}\n\n\n================================================\nFile: src/main.rs\n================================================\n#![warn(clippy::all, clippy::pedantic, clippy::print_stdout)]\n#![allow(dead_code)]\nmod editor;\nuse editor::Editor;\n\nfn main() {\n    Editor::new().run();\n}\n\n\n================================================\nFile: src/editor/terminal.rs\n================================================\nuse core::fmt::Display;\nuse crossterm::cursor::{Hide, MoveTo, Show};\nuse crossterm::style::Print;\nuse crossterm::terminal::{disable_raw_mode, enable_raw_mode, size, Clear, ClearType};\nuse crossterm::{queue, Command};\nuse std::io::{stdout, Error, Write};\n\n#[derive(Copy, Clone)]\npub struct Size {\n    pub height: u16,\n    pub width: u16,\n}\n\n#[derive(Copy, Clone)]\npub struct Position {\n    pub x: u16,\n    pub y: u16,\n}\n\npub struct Terminal;\n\nimpl Terminal {\n    pub fn initialise() -> Result<(), Error> {\n        enable_raw_mode()?;\n        Self::clear_screen()?;\n        Self::move_cursor_to(Position { x: 0, y: 0 })?;\n        Self::execute()?;\n        Ok(())\n    }\n\n    pub fn terminate() -> Result<(), Error> {\n        Self::execute()?;\n        disable_raw_mode()?;\n        Ok(())\n    }\n\n    pub fn clear_screen() -> Result<(), Error> {\n        Self::queue_command(Clear(ClearType::All))?;\n        Ok(())\n    }\n\n    pub fn clear_line() -> Result<(), Error> {\n        Self::queue_command(Clear(ClearType::CurrentLine))?;\n        Ok(())\n    }\n\n    pub fn move_cursor_to(position: Position) -> Result<(), Error> {\n        Self::queue_command(MoveTo(position.x, position.y))?;\n        Ok(())\n    }\n\n    pub fn size() -> Result<Size, Error> {\n        let (width, height) = size()?;\n        Ok(Size { height, width })\n    }\n\n    pub fn hide_cursor() -> Result<(), Error> {\n        Self::queue_command(Hide)?;\n        Ok(())\n    }\n\n    pub fn show_cursor() -> Result<(), Error> {\n        Self::queue_command(Show)?;\n        Ok(())\n    }\n\n    pub fn print<T: Display>(string: T) -> Result<(), Error> {\n        Self::queue_command(Print(string))?;\n        Ok(())\n    }\n\n    pub fn execute() -> Result<(), Error> {\n        stdout().flush()?;\n        Ok(())\n    }\n\n    fn queue_command<T: Command>(command: T) -> Result<(), Error> {\n        queue!(stdout(), command)?;\n        Ok(())\n    }\n}", "tree": "Directory structure:\n\u2514\u2500\u2500 mushrimpy-briskit_editor/\n    \u251c\u2500\u2500 Cargo.toml\n    \u2514\u2500\u2500 src/\n        \u251c\u2500\u2500 editor.rs\n        \u251c\u2500\u2500 main.rs\n        \u2514\u2500\u2500 editor/\n            \u2514\u2500\u2500 terminal.rs\n"}